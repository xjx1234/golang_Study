# 6. Go语言并发编程



## 6.1 并发基础简述

- **进程 & 线程 & 协程**

  

  **进程：**直观点说，保存在硬盘上的程序运行以后，会在内存空间里形成一个独立的内存体，这个内存体有自己独立的地址空间，有自己的堆，上级挂靠单位是操作系统。操作系统会以进程为单位，分配系统资源（CPU时间片、内存等资源），进程是资源分配的最小单位。

  

  **线程：**有时被称为轻量级进程(Lightweight Process，LWP），是操作系统调度（CPU调度）执行的最小单位。

  

  结合下图来理解进程和线程之间的关系：

  <img src="https://golang-do-image.oss-cn-hangzhou.aliyuncs.com/29270628_1382541951nJe7.jpg" style="zoom: 100%;" />

  

  这副图是一个双向多车道的道路图，假如我们把整条道路看成是一个“进程”的话，那么图中由白色虚线分隔开来的各个车道就是进程中的各个“线程”了。

  - 这些线程(车道)共享了进程(道路)的公共资源(土地资源)
  - 这些线程(车道)必须依赖于进程(道路)，也就是说，**线程不能脱离于进程而存在(就像离开了道路，车道也就没有意义了)**
  - 这些线程(车道)之间可以并发执行(各个车道你走你的，我走我的)，也可以互相同步(某些车道在交通灯亮时禁止继续前行或转弯，必须等待其它车道的车辆通行完毕)
  - 这些线程(车道)之间依靠代码逻辑(交通灯)来控制运行，一旦代码逻辑控制有误(死锁，多个线程同时竞争唯一资源)，那么线程将陷入混乱，无序之中
  - 这些线程(车道)之间谁先运行是未知的，只有在线程刚好被分配到CPU时间片(交通灯变化)的那一刻才能知道

  

  **协程：** 英文Coroutines，是一种基于线程之上，但又比线程更加轻量级的存在，这种由程序员自己写程序来管理的轻量级线程叫做『用户空间线程』，具有对内核来说不可见的特性。

  子程序，或者称为函数，在所有语言中都是层级调用，比如A调用B，B在执行过程中又调用了C，C执行完毕返回，B执行完毕返回，最后是A执行完毕。所以子程序调用是通过栈实现的，**一个线程就是执行一个子程序**。子程序调用总是一个入口，一次返回，调用顺序是明确的。而协程的调用和子程序不同。**协程在子程序内部是可中断的，然后转而执行别的子程序，在适当的时候再返回来接着执行**。

  协程的特点在于是一个线程执行，那和多线程比，协程有何优势？

  - 极高的执行效率：因为子程序切换不是线程切换，而是由程序自身控制，因此，没有线程切换的开销，和多线程比，线程数量越多，协程的性能优势就越明显；
  - 不需要多线程的锁机制：因为只有一个线程，也不存在同时写变量冲突，在协程中控制共享资源不加锁，只需要判断状态就好了，所以执行效率比多线程高很多。

  

  

- **并发和并行**

  **并发：** 英文叫作 concurrency。它是指同一时刻只能有一条指令执行，但是多个线程的对应的指令被快速轮换地执行。比如：一个处理器，它先执行线程 A 的指令一段时间，再执行线程 B 的指令一段时间，再切回到线程 A 执行一段时间。由于处理器执行指令的速度和切换的速度非常非常快，人完全感知不到计算机在这个过程中有多个线程切换上下文执行的操作，这就使得宏观上看起来多个线程在同时运行。但微观上只是这个处理器在连续不断地在多个线程之间切换和执行，每个线程的执行一定会占用这个处理器一个时间片段，同一时刻，其实只有一个线程在执行。

  **并行：** 英文叫作 parallel。它是指同一时刻，有**多条指令在多个处理器上同时执行**，并行必须要依赖于多个处理器。不论是从宏观上还是微观上，多个线程都是在同一时刻一起执行的。**并行只能在多处理器系统中存在**，如果我们的计算机处理器只有一个核，那就不可能实现并行。

  并行与并发如下图关系：

  <img src="https://golang-do-image.oss-cn-hangzhou.aliyuncs.com/8da3d114-8543-4e74-8d0d-9f5969af707d.png" style="zoom: 67%;" />

## 6.2  Goroutine

goroutine 是 Go语言中的轻量级线程实现，由 Go 运行时（runtime）管理。Go 程序会智能地将 goroutine 中的任务合理地分配给每个 CPU。

Go 程序从 main 包的 main() 函数开始，在程序启动时，Go 程序就会为 main() 函数创建一个默认的 goroutine。

创建 goroutine 的写法如下， 使用 go 关键字创建 goroutine 时，被调用函数的返回值会被忽略：

```
go 函数名( 参数列表 )
```

- 函数名：要调用的函数名。
- 参数列表：调用函数需要传入的参数。

创建 单个 `goroutine`  示例：

```go
import "fmt"

//创建 sayHello 函数
func sayHello() {
	fmt.Println("Hello")
}

func main() {
	go sayHello()
	fmt.Println("main end")
}
```

编译运行的结果不一，有时候返回 

```
Hello
main end
```

有时候直接返回 ： `main end`，这是什么原因呢？

在程序启动时，Go程序就会为main()函数创建一个默认的goroutine。当main()函数返回的时候该goroutine就结束了，所有在main()函数中启动的goroutine会一同结束，所以我们要想办法让main函数等一等hello函数，最简单粗暴的方式就是让main程序sleep，修改示例如下：

```go
import (
	"fmt"
	"time"
)

//创建 sayHello 函数
func sayHello() {
	fmt.Println("Hello")
}

func main() {
	go sayHello()
	fmt.Println("main end")
	time.Sleep(1)
}
```

执行上面的代码你会发现，这一次先打印 `Hello`，然后紧接着打印  `main end` 。

go 关键字后也可以为匿名函数或闭包启动 goroutine，使用匿名函数或闭包创建 goroutine 时，除了将函数定义部分写在 go 的后面之外，还需要加上匿名函数的调用参数，格式如下：

```
go func( 参数列表 ){
    函数体
}( 调用参数列表 )
```

其中：

- 参数列表：函数体内的参数变量列表。
- 函数体：匿名函数的代码。
- 调用参数列表：启动 goroutine 时，需要向匿名函数传递的调用参数。

示例：

```go
import (
	"fmt"
	"time"
)

func main() {
	go func(i int) {
		for {
			i++
			fmt.Println("i:", i)
			if i > 10 {
				break
			}
		}

	}(0)
	time.Sleep(time.Second)
}
```

运行结果：

```
i: 1
i: 2
i: 3
i: 4
i: 5
i: 6
i: 7
i: 8
i: 9
i: 10
i: 11
```



## 6.3 调整并发的运行性能

在 Go语言程序运行时（runtime）实现了一个小型的任务调度器。这套调度器的工作原理类似于操作系统调度线程，Go 程序调度器可以高效地将 CPU 资源分配给每一个任务。传统逻辑中，开发者需要维护线程池中线程与 CPU 核心数量的对应关系。同样的，Go 地中也可以通过 runtime.GOMAXPROCS() 函数做到，格式为：

```
runtime.GOMAXPROCS(逻辑CPU数量)
```

这里的逻辑CPU数量可以有如下几种数值：

- <1：不修改任何数值。
- =1：单核心执行。
- \>1：多核并发执行。

一般情况下，可以使用 runtime.NumCPU() 查询 CPU 数量，并使用 runtime.GOMAXPROCS() 函数进行设置，例如：

```
runtime.GOMAXPROCS(runtime.NumCPU())
```

Go 1.5 版本之前，默认使用的是单核心执行。从 Go 1.5 版本开始，默认执行上面语句以便让代码并发执行，最大效率地利用 CPU。

GOMAXPROCS 同时也是一个环境变量，在应用程序启动前设置环境变量也可以起到相同的作用。



## 6.4 通道Channel

如果说 goroutine 是 Go语言程序的并发体的话，那么 channels 就是它们之间的通信机制。一个 channels 是一个通信机制，它可以让一个 goroutine 通过它给另一个 goroutine 发送值信息。每个 channel 都有一个特殊的类型，也就是 channels 可发送数据的类型。

Go语言提倡使用通信的方法代替共享内存，当一个资源需要在 goroutine 之间共享时，通道在 goroutine 之间架起了一个管道，并提供了确保同步交换数据的机制。声明通道时，需要指定将要被共享的数据的类型。可以通过通道共享内置类型、命名类型、结构类型和引用类型的值或者指针。

Go语言中的通道（channel）是一种特殊的类型。在任何时候，同时只能有一个 goroutine 访问通道进行发送和获取数据。goroutine 间通过通道就可以通信。

通道像一个传送带或者队列，总是遵循先入先出（First In First Out）的规则，保证收发数据的顺序。



### 6.4.1 声明与创建通道



channel是一种类型，一种引用类型。声明通道类型的格式如下：

```
var 变量 chan 元素类型
```

chan 类型的空值是 nil，声明后需要配合 make 后才能使用。

通道是引用类型，需要使用 make 进行创建，格式如下：

```
通道实例 := make(chan 数据类型)
```

- 数据类型：通道内传输的元素类型。
- 通道实例：通过make创建的通道句柄

声明与创建通道代码示例：

```go
func main() {
	var chan1 chan int //声明int类型通道chan1
	fmt.Println(chan1)
	chan1 = make(chan int) //创建chan1通道，并分配初始化地址
	fmt.Println(chan1)
	chan2 := make(chan string) //创建string类型通道chan2
	fmt.Println(chan2)
}
```

编译运行结果：

```
<nil>
0xc000040060
0xc0000400c0
```



### 6.4.2 使用通道发送和接收数据

通道创建后，就可以使用通道进行发送和接收操作。

- **通道发送数据**

  将数据通过通道发送的格式为：

  ```
  通道变量 <- 数据
  ```

  示例：

  ```go
  func main() {
  	chan1 := make(chan interface{}) //定义数据为任意数据的通道chan1
  	chan1 <- 1                      //将数据1 发送到通道 chan1中
  	chan1 <- 2                      //将数据2 发送到通道 chan1中
  }
  ```

  把数据往通道中发送时，如果接收方一直都没有接收，那么发送操作将持续阻塞。Go 程序运行时能智能地发现一些永远无法发送成功的语句并做出提示：`fatal error: all goroutines are asleep - deadlock!`

- **通道接收数据**

  通道接收同样使用`<-`操作符，接收数据可以有以下写法：

  1.  阻塞式接收数据

     阻塞模式接收数据时，将接收变量作为`<-`操作符的左值，格式如下：

     ```go
     data := <-ch
     ```

     执行该语句时将会阻塞，直到接收到数据并赋值给 data 变量。

  2. 非阻塞式接收数据

     使用非阻塞方式从通道接收数据时，语句不会发生阻塞，格式如下：

     ```go
     data, ok := <-ch
     ```

     非阻塞的通道接收方法可能造成高的 CPU 占用，因此使用非常少。

  3. 接收任意数据

     阻塞接收数据后，忽略从通道返回的数据，格式如下：

     ```go
     <-ch
     ```

     执行该语句时将会发生阻塞，直到接收到数据，但接收到的数据会被忽略。这个方式实际上只是通过通道在 goroutine 间阻塞收发实现并发同步。

  4. 循环接收

     通道的数据接收可以借用 for range 语句进行多个元素的接收操作，格式如下：

     ```go
     for data := range ch {
     }
     ```

     通道 ch 是可以进行遍历的，遍历的结果就是接收到的数据。数据类型就是通道的数据类型。通过 for 遍历获得的变量只有一个，即上面例子中的 data。

  

  【示例一】通道发送和接收数据：

  ```go
  func main() {
  	chan1 := make(chan interface{}) //定义数据为任意数据的通道chan1
  	go func() {
  		fmt.Println("start goroutine")
  		chan1 <- 1 //将数据1发送到通道 chan1中
  		fmt.Println("exit goroutine")
  	}()
  	fmt.Println("wait goroutine")
  	data := <-chan1 //接收通道chan1 数据
  	fmt.Println(data)
  }
  ```

  编译结果：

  ```
  wait goroutine
  start goroutine
  exit goroutine
  1
  ```

  

  【示例二】 通道循环接收数据

  ```go
  func main() {
  
  	ch := make(chan interface{}) //定义数据为任意数据的通道ch
  
  	go func() {
  		for i := 0; i <= 10; i++ {
  			ch <- i //往通道ch发送数据
  			time.Sleep(time.Second)
  		}
  	}()
  
  	for data := range ch { //循环接收通道ch数据
  		fmt.Println(data)
  		if data == 10 {
  			break //退出关闭chan通道，否则会报错
  		}
  	}
  	fmt.Println("end")
  }
  ```

  编译运行结果：

  ```
  0
  1
  2
  3
  4
  5
  6
  7
  8
  9
  10
  end
  
  ```



### 6.4.3 单向通道



### 6.4.4 缓冲通道



### 6.4.5  通道的超时机制



### 6.4.6  通道多路复用(select)



## 6.5 并发安全与锁



## 6.6 等待组

