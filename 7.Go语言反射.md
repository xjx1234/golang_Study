# 7. Go语言反射



## 7.1 反射基本概念与类型信息获取

反射： 在编译时不知道类型的情况下，可更新变量、运行时查看值、调用方法以及直接对他们的布局进行操作的机制。

反射是指在程序运行期对程序本身进行访问和修改的能力，程序在编译时变量被转换为内存地址，变量名不会被编译器写入到可执行部分，在运行程序时程序无法获取自身的信息。支持反射的语言可以在程序编译期将变量的反射信息，如字段名称、类型信息、结构体信息等整合到可执行文件中，并给程序提供接口访问反射信息，这样就可以在程序运行期获取类型的反射信息，并且有能力修改它们。

Go语言提供了 reflect 包来访问程序的反射信息。

reflect提供了两种类型来进行访问接口变量的内容：

| 类型              | 作用                                                         |
| ----------------- | ------------------------------------------------------------ |
| reflect.ValueOf() | 获取输入参数接口中的数据的值，如果为空则返回**0** <- 注意是0 |
| reflect.TypeOf()  | 动态获取输入参数接口中的值的类型，如果为空则返回**nil** <- 注意是nil |

- **reflect.Type**

  在Go语言程序中，使用 reflect.TypeOf() 函数可以获得任意值的类型对象（reflect.Type），在使用反射时，需要首先理解类型（Type）和种类（Kind）的区别。

  相较于 Type 而言，Kind 所表示的范畴更大。类似于家用电器（Kind）和电视机（Type）之间的对应关系。或者电视机（Kind）和 42 寸彩色电视机（Type）。Type 是类型。Kind 是类别。Type 和 Kind 可能相同，也可能不同。通常基础数据类型的 Type 和 Kind 相同，自定义数据类型则不同。

  

  Type指的是系统原生数据类型，如 int、string、bool、float32 等类型，以及使用 type 关键字定义的类型，这些类型的名称就是其类型本身的名称。例如使用 type A struct{} 定义结构体时，A 就是 struct{} 的类型。

  而种类（Kind）指的是对象归属的品种，在 reflect 包中有如下定义：

  ```go
  const (
      Invalid Kind = iota
      Bool
      Int
      Int8
      Int16
      Int32
      Int64
      Uint
      Uint8
      Uint16
      Uint32
      Uint64
      Uintptr
      Float32
      Float64
      Complex64
      Complex128
      Array
      Chan
      Func
      Interface
      Map
      Ptr
      Slice
      String
      Struct
      UnsafePointer
  )
  ```

  代码示例如下：

  ```go
  import (
  	"fmt"
  	"reflect"
  )
  
  // 声明一个空结构体
  type MyData struct {
  }
  
  func main() {
  	var a int //声明int类型变量a
  	typeofA := reflect.TypeOf(a) // 获取变量a的反射类型对象
  	fmt.Println(typeofA.Kind(), typeofA.Name())
  	typeofData := reflect.TypeOf(MyData{}) // 获取结构体实例的反射类型对象
  	fmt.Println(typeofData.Kind(), typeofData.Name())
  }
  ```

  编译运行结果：

  ```
  int int
  struct MyData
  ```

  如上代码， 使用 `typeofA.Kind()` 来获取 `Kind` 种类， 使用 `typeofA.Name()`  来获取 `Type` 类型 。

- **reflect.Value**

  Go语言中，使用 reflect.ValueOf() 函数获得值的反射值对象（reflect.Value）。书写格式如下：

  ```go
  value := reflect.ValueOf(rawValue)
  ```

  reflect.ValueOf 返回 reflect.Value 类型，包含有 rawValue 的值信息。reflect.Value 与原值间可以通过值包装和值获取互相转化。reflect.Value 是一些反射操作的重要类型，如反射调用函数。

  Go语言中可以通过 reflect.Value 重新获得原始值。通过下面几种方法从反射值对象 reflect.Value 中获取原值，如下表所示：

  | 方法名                   | 说  明                                                       |
  | ------------------------ | ------------------------------------------------------------ |
  | Interface() interface {} | 将值以 interface{} 类型返回，可以通过类型断言转换为指定类型  |
  | Int() int64              | 将值以 int 类型返回，所有有符号整型均可以此方式返回          |
  | Uint() uint64            | 将值以 uint 类型返回，所有无符号整型均可以此方式返回         |
  | Float() float64          | 将值以双精度（float64）类型返回，所有浮点数（float32、float64）均可以此方式返回 |
  | Bool() bool              | 将值以 bool 类型返回                                         |
  | Bytes() []bytes          | 将值以字节数组 []bytes 类型返回                              |
  | String() string          | 将值以字符串类型返回                                         |

  代码使用示例：

  ```go
  import (
  	"fmt"
	"reflect"
  )
  
  func main() {
  	var a int = 100                      // 声明整型变量a并赋初值
  	valueofA := reflect.ValueOf(a)       // 获取变量a的反射值对象
  	var av1 = valueofA.Interface().(int) // 获取interface{}类型的值, 通过类型断言转换
  	var av2 = valueofA.Int()             // 获取64位的值, 强制类型转换为int类型
  	fmt.Println(av1, av2)
  }
  ```
  
  代码输出如下：
  
  ```
  100 100
  ```



## 7.2 获取指针指向元素类型

通过 reflect.Elem() 方法获取这个指针指向的元素类型。这个获取过程被称为取元素，等效于对指针类型变量做了一个`*`操作，代码如下：

```go

```



## 7.3 获取结构体相关信息



